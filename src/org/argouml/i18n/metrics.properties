#o pacote deste arquivo se refere ao org.argouml.i18n para que possa
#ser reutilizado o Translator. Toda chave deve começar com "metrics."

metrics.Metrica=Metricas
metrics.Menu=Calcular métrica
metrics.Metrica=Metricas

#Nome dos submenus
metrics.AttributeHidingFactor=Fator de Invisibilidade de Atributos
metrics.MethodHidingFactor=Fator de Invisibilidade de Métodos
metrics.MethodInheritanceFactor=Fator Herança de Métodos
metrics.PolymorphismFactor=Fator de Polimorfismo
metrics.NAgg=Numero de Agregações
metrics.NAssoc=Número de Associações
metrics.NAssocXClasses=Número Associações X Classes
metrics.NGen=Número de Generalizações
metrics.ClassDependencyAverage=Média de Dependência das Classes.
metrics.ClassDependencyStandardDesviation=Desvio Padrão Dependência das Classes
metrics.DepthInheritanceTree=Profundidade Herança
metrics.ImmediateSubClasses=SubClasses Imediatas
metrics.NumberHierarchiesRoots=Total de Classes Raízes
metrics.OverallNumberClass=Total de Classes
metrics.ClassReport=Relatório Completo
metrics.CouplingFactor=Fator de Acoplamento
metrics.InterPackageClassCoupling=Acomplamento Classes
metrics.configurations=Configurações

#Abas do diálogo
metrics.chart=Gráfico
metrics.info=Info
metrics.result=Resultado


#Infos conteúdo
metrics.info.AttributeHidingFactor=<html><p>É a razão entre a soma dos atributos invisíveis definidos em todas as classes</p><p> (A invisibilidade de um atributo é a porcentagem do total de classes que esse método não está acessível.)</p><p>pelo número total de atributos definidos no sistema em construção.</p><p> O paradigma na qual essa métrica trabalha é o encapsulamento.</p><p> Segundo [3], idealmente todos os atributos deveriam ser invisíveis e somente acessados por métodos</p><p> do tipo Getters and Setters.</p><p> Assim, AHF=100%.  (Aqui surge uma nova métrica, medir métodos acessadores como Getter and Setter, o quão são acessíveis os atributos por métodos)</p><p><b><u>Objetivo</u>:</b> Segundo [1], medir o conceito de invisibilidade de informação que é suportado pelo mecanismo</p><p> de encapsulamento.</p><p>Harrison [4] mostrou essa métrica é válida dentro do contexto de um framework proposto por Kit [5].</p></html>

metrics.info.NAssocXClasses=<html><p>É a razão entre o número de associações e o número de classes que um pacote tem.</p><p> <b><u>Objetivo</u>:</b> Quanto mais associações por classe um pacote tem, mais complexo ele será, </p><p>e consequentemente mais difícil de enteder e manter.</p></html>

metrics.info.ClassDependencyAverage=<html><p>É o valor da média do número de dependências diretas de uma classe.</p><p> É a soma de todas as dependências dividido pelo número de classes.</p><p><b><u>Objetivo</u>:</b> Essa métrica mede a complexidade global de todo um diagrama de classes.</p><p> <b>Comentário:</b> É apenas uma proposta e a métrica não foi validada nem empiricamente, nem teoricamente.</p></html>

metrics.info.PolymorphismFactor=<html><p>Representa a razão entre o número atual de diferentes possibilidades de polimorfismo pelo número </p><p>máximo de possíveis situações distintas de polimorfismo para uma classe. </p><p>[3] Um uso apropriado de polimorfismo em projetos OO pode reduzir a densidade de defeitos e retrabalho.</p><p> Entretanto, para valores muito altos da POF (bem maior que 10%) </p><p>é esperado uma redução desses benefícios. </p><p>Na verdade, para entender e debugar uma hierarquia de polimorfismo muito alta, </p><p>será muito mais difícil comparado ao código procedural.</p></html>

metrics.info.MethodInheritanceFactor=<html><p>É o quociente entre a soma dos métodos herdados em todas as classes e o total de métodos </p><p> disponíveis de todas as classes.</p><p><b> <u>Objetivo</u>:</b> [1], é uma medida de herança e uma medida de nível de reuso.</p><p> Em [3], Brito e Abreu demonstrou que quando o valor da MIF aumenta,</p><p> é esperado que a densidade de defeitos e o esforço gasto para fixá-los diminua.</p><p> Isso mostra que como a herança aparece como uma técnica apropriada para reduzir </p><p>a densidade de erros e retrabalho (refatoração), quando utilizada com moderação.</p><p> Segundo [3,6], acredita-se que valores altos, acima de 70 e 80%, </p><p>podem reverter o benefício citado, mas esse pressuposto ainda necessita da validação experimental</p></html> 

metrics.info.MethodHidingFactor=<html><p> É a razão entre a soma do métodos invisíveis definidos em todas as classes pelo total de métodos</p><p> definidos no sistema em consideração. </p><p>Com o aumento da MHF, é esperado uma diminuição na densidade de defeito e no esforço gasto para fixá-lo.</p><p> <b><u>Objetivo</u>:</b> Segundo [1], medir o conceito de invisibilidade de informação que é</p><p> suportado pelo mecanismo de encapsulamento.</p></html>

metrics.info.NumberHierarchiesRoots=<html><p> É o número total de hierarquias de herança.</p><p> <u>Objetivo</u>: Essa métrica mede a complexidade global de um diagrama de classes.</p></html>

metrics.info.DepthInheritanceTree=<html><p> Ela é uma medida de quantas classes ancestrais podem, potencialmente, afetar uma classe.</p><p> <b><u>Observações</u>:</b></p><p> 1.Quanto maior a profundidade da hierarquia de uma classe, </p><p>maior será o número de métodos a serem herdados, assim aumentando a complexidade da mesma.</p><p> 2.Árvores profundas aumentam a complexidade do design,</p><p> uma vez que mais classes e métodos estarão envolvidos. </p><p>3.Quanto maior a profundidade da hierarquia de uma classe, </p><p>maior o potencial de reuso de métodos herdados.</p><p> 4.Observando os valores dessa métrica, segundo [8], </p><p>um desenhista experiente pode afirma quando o seu design é</p><p> top heavy (muitas classes perto da raiz), ou bottom heavy (muitas classes estão perto do fundo da árvore).</p><p> No primeiro caso, pode-se citar como desvantagem o mau aproveitamento do reuso de métodos.</p><p> No segundo caso, devido ao alto número de métodos herdados,</p><p> pode ficar difícil o número de testes varrendo todos eles.</p></html> 

metrics.info.OverallNumberClass=<html><p>Mede o número total de classes. </p><p>Segundo [9], essa métrica captura a noção do tamanho total de um sistema.</p><p> Quanto maior o número de classes, maior será o esforço para construir o sistema.</p><p><b> <u>Objetivo</u>:</b> Essa métrica mede a complexidade global de um diagrama de classes.</p></html>

metrics.info.NGen=
metrics.info.NAssoc=<html><p>É o número total de associações que uma classe em um diagrama de classes possui.</p><p> <b><u>Objetivo</u>:</b> A complexidade de uma classe depende do número de associações que ela possui com outras classes.</p><p> Essa métrica consegue identificar quais classes são as principais em um modelo.</p></html>

metrics.info.NAgg=<html><p>É definido como o número de relacionamentos do tipo agregação dentro de um pacote.</p><p> <b><u>Objetivo</u>:</b> Medir a complexidade de um pacote. Um maior número de relacionamentos agregação constitui uma complexidade de design maior.</p><p> Com isso, pode ser requerido um maior custo na implementação e na manutenção.</p><p> Essa métrica foi teoricamente validada em [2]</p></html>

metrics.info.CouplingFactor=<html><p>É razão entre número atual de acomplamentos, não considerando herança pelo número máximo de acomplamento em um sistema com n classes.</p><p>É considerado acomplamento entre duas classes os seguintes cenários:</p><p> 1) Passagem de mensagem regular - chamada de um método em uma classe.</p><p> 2) Passagem de mensagem forçada</p><p> 3) Chamada ao construtor ou desconstrutor </p><p>4) Referência a classe servidora como um membro, ou como parâmetro de função.</p><p> Resultados de [3] comprovaram que o acomplamento em um sistema tem um forte impacto negativo na qualidade do software, </p><p>uma vez que com o aumento do acomplamento é esperado um aumento no retrabalho e na densidade de erros.</p><p> Assim, o ideal é que o valor seja o mínimo possível. </p><p>É desejável que as classes se comuniquem com outras o mínimo possível </p><p> porque acomplamento aumenta a complexidade, reduz o encapsulamento, </p><p>potenciais reusos e limita o entendimento e manutenabilidade.</p></html>


metrics.NAgg.x=Classes
metrics.NAgg.y=Nº Agregações
metrics.DepthInheritance.labelX=Classes
metrics.DepthInheritance.labelY=Nº Classes Hierarquia
metrics.ClassDependencyAverage.label1=
metrics.ClassDependencyAverage.label2=
metrics.NAssocXClasses.label1=
metrics.NAssocXClasses.label2=
metrics.NAssoc.x=Classes
metrics.NAssoc.y=Nº Associações
metrics.PolymorphismFactor.label1=
metrics.PolymorphismFactor.label2=
metrics.MethodHidingFactor.label2=Métodos Visíveis
metrics.MethodHidingFactor.label1=Métodos Invisíveis
metrics.AttributeHidingFactor.label1=Atributos Invisíveis
metrics.AttributeHidingFactor.label2=Atributos Visíveis
metrics.MethodInheritanceFactor.label1=Métodos Herdados
metrics.MethodInheritanceFactor.label2=Métodos não Herdados
metrics.CouplingFactor.label1=
metrics.CouplingFactor.label2=

metric.report=Relatório Completo

metrics.configurationFrameTitle=Configurações
metrics.measureScope=Selecione o escopo de análise 
metrics.categoryMenu=Menu Métricas Categorizadas
metrics.Menu.oo=OO
metrics.Menu.encapsulation=Encapsulamento
metrics.Menu.inheritance=Heranca
metrics.Menu.polymorphism=Polimorfismo
metrics.Menu.complexity=Complexidade
metrics.Menu.size=Tamanho
metrics.okbutton=Ok



